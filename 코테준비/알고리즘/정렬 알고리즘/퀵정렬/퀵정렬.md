1. 개념
   • 데이터를 하나의 기준점(피벗)으로 나누고, 작은 값은 왼쪽, 큰 값은 오른쪽으로 분류한 뒤 재귀적으로 정렬.
   • “쪼개면서 바로 정렬한다”는 전략을 사용.

2. 알기 쉽게 설명
   • 책꽂이에 책을 정렬한다고 가정해 보세요.

   1. 첫 번째 책(피벗)을 기준으로 잡습니다.
      • 예: [7, 3, 9, 1, 5, 6, 4, 8]
      • 피벗: 7
   2. 피벗보다 작은 책은 왼쪽에, 큰 책은 오른쪽에 둡니다.
      • [3, 1, 5, 6, 4] (작은 값들) | [7] | [9, 8] (큰 값들)
   3. 왼쪽과 오른쪽 묶음을 다시 같은 방식으로 정렬합니다.
      • [3, 1, 5, 6, 4] → 피벗: 3 → [1] | [3] | [5, 6, 4]
      • [5, 6, 4] → 피벗: 5 → [4] | [5] | [6]
   4. 모든 작은 묶음과 큰 묶음을 합치면 정렬된 리스트가 됩니다.
      • [1] → [1, 3] → [1, 3, 4, 5, 6, 7, 8, 9]

3. 장점
   • 메모리를 추가로 쓰지 않음.
   • 평균적으로 **O(n log n)**의 성능.

4. 단점
   • 최악의 경우(데이터가 이미 정렬된 경우), **O(n²)**가 될 수 있음.
   • 불안정한 정렬 방식(같은 값끼리의 순서가 유지되지 않을 수 있음).
