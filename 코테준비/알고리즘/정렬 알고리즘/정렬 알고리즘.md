1. 선택 정렬(Selection Sort)
매 단계에서 (아직처리되지않은 데이터중)가장 작은 원소를 선택해서 앞으로 보내는 방법 (선택을 위해 약 N번의 연산)
앞으로 보내진 원소는 더 이상 위치가 변경되지 않음
시간 복잡도 O(N^2)로 비효율적인 알고리즘 중 하나, but 데이터 갯수가 적고 정렬라이브러리 사용 불가능 할때 굉장히 빠르게 작성가능

- 동작방식
  각 단계에서 가장 작은 원소 선택
  현재까지 처리 되지 않은 원소들 중 가장 앞의 원소와 위치를 교체


2. 버블정렬(Bubble Sort)
다소 인접한 두원소를 확인하여, 정렬이 안되어 있다면 위치를 서로 변경합니다.
서로 인접한 두 원소를 비교하는 형태가 거품과 같다고 붙여진 이름
시간 복잡도 O(N^2)로 비효율적인 정렬 알고리즘 중 하나

- 각단계에서는 인접한 두 개의 원소비교를 통해 필요 시 위치 변경
- 첫째, 둘째 비교, 둘째 셋째 비교, 셋째 넷째 비교하는 방식. 매 단계를 거칠때 마다 큰 원소가 맨 뒤(오른쪽)로 가게됨


3. 삽입정렬(Insertion Sort)
- 각 단계에서 현재 원소가 삽입될 위치 찾음, 적절한 위치에 삽입
- 적절한 위치에 도달할때까지 반복적으로 왼쪽으로 이동
- 상대적으로 효율적으로 동작함 (배열 상태에 따라 달라지긴함)
- 이미 정렬이완료되어있는 상태에서는 빠르게 동작함
- 매 단계에서 현재 처리 중인 원소가 삽입될 위치를 찾기 위해 약 N번의 연산 필요.
- 결과적으로 N개의 단계를 거쳐 최악의 경우 O(N^2) 시간복잡도

4. 분할 정복
 - 분할 : 큰 문제를 작은 부분 문제로 분할
 - 정복 : 작은 문제 각각 해결
 - 조합 : 해결한 부분 문제의 답을 이용하여 다시 큰 문제 해결

- 단점 : 재귀함수를 사용한다는 점에서 함수 호출 횟수가 많아짐
- 이는 오버헤드(overhead)로 이어짐

5. 병합정렬
 - 분할정복 아이디어를 사용하는 정렬 알고리즘
 - 시간복잡도 O(NlogN)을 보장하는 빠른 정렬 알고리즘
 - 분할 : 정렬할 배열(큰문제)을 같은 크기의 부분배열(작은문제) 2개로 분할
 - 정복 : 부분 배열을 정렬함(작은문제해결)  과정에서 임시배열필요
 - 조합 : 정렬된 부분 배열을 하나의 배열로 다시 병합한다
 - 소요시간이 짧으나 메모리가 많이 필요하여 비효율적인 부분이 있음

 6. 정렬 라이브러리
  - 이미 구현되어있는 정렬라이브러리 사용, 효율적
  - JavaScript 배열에 포함된 데이터를 정렬하는 sort()함수 제공
  - 최악의 경우 시간 복잡도 O(NlogN) 보장
  - 정렬기능이 필요하면 sort()함수 사용하는 것을 권장
  - sort() 함수 제한, 병합정렬과 같은 알고리즘 직접 구현하여 사용

 7. JavaScript정렬 기준 함수(Compare Function)
  - JavaScript 정렬함수에서는 정렬기준함수가 사용된다.
  - 두개의 원소 a,b 입력 받는다
  1. 반환값이 0보다 작은 경우 -> a가 우선순위가 높아 앞에 위치
  2. 반환값이 0보다 큰 경우 -> b가 우선순위가 높아 앞에 위치
  3. 반환값이 0인 경우 -> a와 b의 순서를 변경X
  - 정렬 기준함수를 사용하지 않으면 각 원소는 문자열로 취급된다.
  - 유니코드 값 순서대로 정렬
  - 따라서, 항상 정렬 기준 함수를 명시하는 습관을 들일 필요가 있음
